* http://doc.workerman.net/315124

## 1. 通讯协议作用
* 由于TCP是基于流的，客户端发送的请求数据是像水流一样流入到服务端，服务端探测到有数据到来后应该检查数据是否是完整的，因为可能只是一个请求的部分数据到达服务端，甚至可能是多个请求连在一起到达服务端。 **如何判断请求是否全部到达或者从多个连在一起的请求中分离请求，就需要规定一套通讯协议**

### 在WorkerMan中为什么要制定协议？
* 传统PHP开发都是基于Web的，基本上都是HTTP协议，**HTTP 协议的解析处理都由 WebServer 独自承担了，所以开发者不会关心协议方面的事情**。然而当我们需要基于非HTTP协议开发时，开发者就需要考虑协议的事情了。

* WorkerMan已经支持的协议
    * 目前已经支持HTTP、websocket、text协议(见附录说明)、frame协议(见附录说明)，ws协议(见附录说明

* 使用自定义的通讯协议
    * 当WorkerMan自带的通讯协议满足不了开发需求时，开发者可以定制自己的通讯协议

    * Workerman内置了一个text协议，协议格式为文本+换行符


## 2. 定制通讯协议
* 简单的协议一般包含两部分:
    * 区分数据边界的标识
    * 数据格式定义

* 一个例子
    * 协议定义: 假设区分数据边界的标识为换行符"\n"（注意请求数据本身内部不能包含换行符），数据格式为Json，例如下面是一个符合这个规则的请求包 `{"type":"message","content":"hello"}`

    * 实现步骤: 具体参见 http://doc.workerman.net/315125
        1. 协议文件放到项目的Protocols文件夹，例如文件 MyApp/Protocols/JsonNL.php
        2. 实现JsonNL类，以 `namespace Protocols;` 为命名空间，必须实现三个静态方法分别为 `input、encode、decode` 
            * 注意：workerman会自动调用这三个静态方法，用来实现分包、解包、打包

    * **workerman与协议类交互流程:**
        1. 客户端发送数据包到服务端,服务端收到数据(可能是部分数据)后会立刻调用协议的 input 方法，用来检测这包的长度，input 方法返回长度值 `$length` 给 workerman 框架;

        2. workerman 框架得到这个 `$length`值后判断当前数据缓冲区中是否已经接收到 `$length` 长度的数据，如果没有就会继续等待数据，直到缓冲区中的数据长度不小于 `$length`;

        3. 缓冲区的数据长度足够后，workerman 就会从缓冲区截取出 `$length` 长度的数据(即分包)，并调用协议的 `decode` 方法解包，解包后的数据为 `$data`;

        4. 解包后 workerman 将数据 `$data` 以回调 `onMessage($connection, $data)` 的形式传递给业务，业务在 `onMessage` 里就可以使用 `$data` 变量得到客户端发来的完整并且已经解包的数据了;

    * 具体实现:
        * 见源地址 ...



## 3. 一些例子

### 例子一: 协议定义 数据包样本 协议实现
* ...

* TODO: 更多例子同上过程, 具体要手动实现, 建议尝试例子四
